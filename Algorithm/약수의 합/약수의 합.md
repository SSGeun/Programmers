<h1>약수의 합</h1>

* 약수를 구하는 방법 3가지



<h2>1. </h2>

int solution(int n) {
    
    int answer = 0;
    
    for (int i = 1; i <= n; i++) {
        
        if (n % i == 0) {
            
            answer += i;
        }
    }
    
    return answer;
}

* 가장 간단한 방법으로 주어진 수 n에 대해 1부터 n까지 나누어 나머지가 0이 되는 수를 찾는다.



<h2>2.</h2>

int solution(int n) {
    
    int answer = 0;
    
    for (int i = 1; i <= (n / 2); i++) {
        
        if (n % i == 0) {
            
            answer += i;
        }
    }
    
    answer += n;
    
    return answer;
}

* 주어진 수 n을 2로 나누는 이유는?
* (홀수) 15의 약수를 구한다고 생각해보자. **15 / 2 = 7.5**이고, 15의 약수는 1, 3, 5, 15이다. **즉, 15를 제외하면 모든 약수들은 절대 절반을 나눈 값보다 크지 않다.**
* (짝수) 16의 약수를 구한다고 생각해보자. **16 / 2 = 8**이고, 16의 약수는 1, 2, 4, 8, 16이다. **즉, 16을 제외하면 모든 약수들은 절대 절반을 나눈 값보다 크지 않다.**
* 해당 알고리즘에서 주의할 점은 **반복문이 끝난 후 자기 자신 n 값을 포함해야 한다.**



<h2>3.</h2>

int solution(int n) {
    
    int answer = 0;
    
    for (int i = 1; (i * i) <= n; i++) {
        
        if ((i * i) == n) {
            
            answer += i;
            break;
        }
        
        if (n % i == 0) {
            
            answer += i;
            
            answer += (n / i);
        }
    }
    
    return answer;
}

* (홀수, 짝수) 15의 약수를 구한다고 생각해보자. 위의 반복문에서 사용되는 i의 값은 1, 2, 3 총 3개이다. 

  i = 1, 반복문 수행을 통해 약수 1과 15의 값을 구할 수 있다.

  i = 2, 조건에 만족하지 않으므로 아무런 작업도 수행하지 않는다.

  i = 3, 반복문 수행을 통해 약수 3과 5의 값을 구할 수 있다.

* (제곱수) 16의 약수를 구한다고 생각해보자. 위의 반복문에서 사용되는 i의 값은 1, 2, 3, 4 총 4개이다.

  i = 1, 반복문 수행을 통해 약수 1과 16의 값을 구할 수 있다.

  i = 2, 반복문 수행을 통해 약수 2와 8의 값을 구할 수 있다.

  i = 3, 조건에 만족하지 않으므로 아무런 작업도 수행하지 않는다.

  i = 4, 반복문 수행을 통해 약수 4와 4의 값을 구할 수 있다. (**제곱수의 경우 제곱근의 값이 두 번 중복되므로 주의해야 한다.**)